너는 안전교육 자료를 자동으로 생성하는 앱을 만드는 AI 코딩 도우미다.

앱 목적:

* 학교급(초등/중등/고등), 산출물 종류(가정통신문, PDF), 안전교육 테마(화재/일반)를 선택하면, static 폴더의 JSON 데이터를 불러와 Gemini API에 맞는 프롬프트로 전달하고 결과물을 출력한다.

기본 규칙:

* Python/Django를 활용한 MTV 방식으로 제작한다.
* Gemini API를 호출해 동적으로 자료를 생성한다.
* 디렉토리는 `/components`, `/api`, `/static/data`, `/utils`로 나눈다.
* `/utils/promptBuilder.js`에서 학교급·산출물·테마별 프롬프트를 생성한다.

프롬프트 규칙:

* 초등: 친근한 안전교육 전문가 톤
* 중등: 교사 톤
* 고등: 전문 강사 톤
* 가정통신문: 학부모용 공문 형식 (인사말, 주요 내용, 가정 지도, 맺음말)
* PDF: 학생용 학습자료 (제목, 학습목표, 핵심내용, 활동지, 정리)
* 요구사항: 학생 눈높이 맞춤, 실생활 예시, 핵심 수칙 강조, 산출물에 맞는 추가 요소 포함

출력 규칙:

* 가정통신문은 화면 인쇄 가능하게
* PDF는 다운로드 가능하게

너는 이 규칙을 항상 기억하고, 내가 코드를 요청하면 위 구조와 규칙에 맞춰 코드를 작성한다.

----

Django-MTV 안전교육 자료 생성 앱 — 최소 구현 설계
개요

사용자 입력(학교급: 초/중/고, 산출물: 가정통신문/PDF, 테마: 화재/일반)을 받아 static/data의 JSON 자료를 기반으로 LLM(Gemini)을 호출해 산출물을 생성하는 Django(MTV) 애플리케이션의 최소 구현 설계이다. 구현 원칙은 presentation / business / data의 분리이며, 실제 개발과 배포를 빠르게 진행할 수 있도록 최소 스펙을 제시한다.

주의: 원래 요구사항에 utils/promptBuilder.js가 명시되어 있어 프론트에서 프롬프트 미리보기용으로 JS 구현을 유지하고, 백엔드에는 동일 로직의 Python 구현(services/prompt_builder.py)을 둔다. 두 구현은 동일한 템플릿 규칙을 공유한다.

핵심 요구사항(요약)
Django(MTV) 방식으로 구현
Gemini API 호출로 동적 콘텐츠 생성
파일/디렉토리 구조: /components, /api, /static/data, /utils (및 Django 표준 구조)

프롬프트 규칙(톤·구성)은 주어진 대로 엄수

출력: 가정통신문 → 인쇄용 HTML, PDF → 다운로드 가능한 PDF

아키텍처 (레이어)

Presentation (templates + JS components)
Django 템플릿(templates/) + /components 아래의 작은 JS 모듈들

사용자 입력 폼, 결과 뷰(프린트/다운로드 버튼)
Business (Django views / services)
services/prompt_builder.py — 서버 사이드 프롬프트 생성
services/gemini_service.py — Gemini 호출 + 응답 정제
api/views.py — JSON API 엔드포인트 (AJAX용)

Data
/static/data/*.json — 안전교육 자료
models.py (선택): 요청 로그/결과 저장

추천 파일/디렉토리 구조 (최소)
project_root/
├─ manage.py
├─ project_settings/
│  └─ settings.py
├─ edu_app/   # Django app
│  ├─ migrations/
│  ├─ templates/edu_app/
│  │  ├─ index.html
│  │  └─ result_print.html
│  ├─ static/
│  │  ├─ components/        # 프론트 JS (promptBuilder.js 등)
│  │  │  └─ promptBuilder.js
│  │  └─ data/
│  │     ├─ fire_safety.json
│  │     └─ general_safety.json
│  ├─ api/
│  │  └─ views.py           # API endpoints
│  ├─ services/
│  │  ├─ prompt_builder.py  # Python prompt builder (business logic)
│  │  └─ gemini_service.py  # Gemini 호출 로직
│  ├─ models.py             # GenerationRequest 등 (선택)
│  ├─ urls.py
│  └─ views.py              # Template rendering views
├─ Dockerfile
├─ docker-compose.yml (optional)
└─ README.md
데이터 스키마 (static/data/*.json) — 권장 기본 구조
{
  "id": "fire_01",
  "title": "화재 발생 시 대피 요령",
  "age_range": "6-12",
  "key_points": [
    "불 발견 시 큰 소리로 알린다",
    "젖은 수건으로 코와 입을 막고 낮게 기어간다"
  ],
  "scenarios": [
    {"title": "교실에서 화재", "description": "전기콘센트 과열로 시작..."}
  ],
  "checklist": ["소화기 위치 확인", "대피경로 연습"]
}

필드 설명: id, title, age_range, key_points(핵심수칙), scenarios(사례), checklist(가정/학교용 행동목록)

API 설계 (최소 엔드포인트)
GET / — 메인 폼 페이지 (템플릿)
GET /api/static-data/<theme>/ — 선택한 테마의 JSON 반환
POST /api/generate/ — 본 생성 요청 (payload: school_level, output_type, theme, preview)
동작: JSON 불러오기 → prompt_builder.build_prompt(...) → gemini_service.generate(prompt) → 결과 반환
응답: { id, status, result_html (or text), pdf_url (if ready) }
GET /api/result/<id>/ — 비동기 처리를 할 경우 상태 확인
POST /api/generate/pdf/ — (옵션) 서버에서 HTML → PDF 변환

동기 vs 비동기
MVP: 작은 부하를 가정하여 동기 호출로 간단히 구현 (타임아웃 설정 권장)
확장: Gemini 호출과 PDF 생성은 Celery/Redis 등으로 비동기화
prompt_builder 로직 (규칙 및 예시)
역할: school_level, output_type, theme, safety_data를 받아 LLM에 넘길 단일 문자열 프롬프트를 생성

핵심 매핑
school_level -> role tone
output_type -> format template

Python 예시 (간단)

ROLE_MAP = {
  'elementary': '초등학생을 위한 친근한 안전교육 전문가',
  'middle': '중학생의 눈높이에 맞는 안전교육 교사',
  'high': '고등학생을 위한 전문적인 안전교육 강사'
}
FORMAT_MAP = {
  'notice': {
    'format': '학부모님께 전달하는 공식 가정통신문',
    'structure': ['인사말','주요 내용','가정에서의 지도 방법','맺음말']
  },
  'pdf': {
    'format': '학생 교육용 PDF 자료',
    'structure': ['제목','학습목표','핵심내용','활동지','정리']
  }
}

def build_prompt(school_level, output_type, theme, safety_data):
    role = ROLE_MAP[school_level]
    fmt = FORMAT_MAP[output_type]
    prompt = f"당신은 {role}입니다. 다음 데이터를 바탕으로 {fmt['format']} 형식으로 작성하세요.\n"
    prompt += f"테마: {theme}\n데이터: {safety_data}\n구조: {', '.join(fmt['structure'])}\n"
    prompt += "요구: 학생 눈높이, 실생활 예시, 핵심수칙 강조."
    if output_type == 'notice':
        prompt += " 학부모 참여 유도 문구 포함."
    else:
        prompt += " 시각적 구성(활동지 포함) 설명 포함."
    return prompt

클라이언트용 utils/promptBuilder.js
프롬프트 미리보기 기능: 서버 호출 전에 사용자가 볼 수 있게 동일 템플릿으로 프롬프트를 생성
주의: 실제 최종 프롬프트는 반드시 서버의 prompt_builder.py에서 다시 생성/검증
Gemini 연동 (services/gemini_service.py) — 최소 스텁
역할: 프롬프트를 보내고 텍스트를 받아 반환. 에러/타임아웃/재시도 정책 적용.

환경변수: GEMINI_API_KEY, GEMINI_MODEL


중요: Gemini의 실제 HTTP/SDK 인터페이스는 공식 문서를 확인해 구현해야 한다. 위 스텁은 패턴 예시일 뿐이며, 실제 파라미터/응답 키는 공식 SDK/엔드포인트 기준으로 맞춰야 한다.

출력(결과) 처리
가정통신문: 서버에서 HTML 템플릿(result_print.html)으로 렌더링. CSS @media print 적용 → 브라우저 인쇄 버튼 사용.
PDF: 서버에서 HTML → PDF 변환
라이브러리 제안: WeasyPrint(CSS 지원 우수), wkhtmltopdf(환경설정 필요), ReportLab(정교한 PDF)
PDF 생성은 요청이 길거나 동시요청이 많다면 Celery로 비동기 처리
보안·운영 고려사항 (필수)
API 키: Git에 커밋 금지, 환경변수/시크릿 매니저 사용
입력 검증: 클라이언트 입력을 검증하여 허용된 값만 처리
프롬프트 인젝션 방지: safety_data는 서버에서 읽고 prompt를 구성. 외부 입력이 그대로 prompt에 들어가지 않도록 escape/검증
타임아웃 & 재시도: Gemini 호출 타임아웃 설정 및 재시도(지수 백오프)
로깅/모니터링: 요청/응답 로깅(민감 데이터 마스킹), Sentry 연동 권장
레이트 리밋: Abuse 방지

테스트 계획 (MVP)
Unit: prompt_builder.build_prompt 동작 테스트 (입력에 따른 프롬프트 규칙 검증)
Integration: gemini_service를 모킹해 API 응답 흐름 테스트

E2E: 브라우저에서 폼 제출 → 결과 확인(간단)

배포(간단 권장)
Dockerize Django 앱 + Gunicorn + WhiteNoise(static serving)
정적 데이터는 앱 내에 포함하거나 S3로 분리
환경: Render/Cloud Run 같은 PaaS에서 빠르게 배포 가능
CI: GitHub Actions로 테스트 → 도커 빌드 → 컨테이너 레지스트리 → 배포

확장(향후)

Gemini 호출 큐잉(Celery + Redis)
프롬프트 A/B 테스트 로깅(어떤 템플릿이 더 나은지 측정)
관리자 UI: 수동으로 JSON 데이터 편집 가능
다국어 확장 (한국어/영어)

다음 단계 (권장 순서)
edu_app 생성 + 기본 URL 연결
static/data에 예제 JSON 2개 추가
services/prompt_builder.py와 utils/promptBuilder.js 동시 구현(동일 규칙)
services/gemini_service.py 스텁 추가 (환경변수로 KEY/ENDPOINT 설정)
api/views.py에 /api/generate/ 엔드포인트 구현 (동기 MVP)
결과 표시 템플릿 추가 및 프린트/PDF 기능 연결